
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>December11</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-12-11"><meta name="DC.source" content="December11.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Sparse Optimization MM Algorithm</a></li><li><a href="#2">A comparison of all these methods</a></li><li><a href="#3">Extending to PSD Rank Minimization</a></li><li><a href="#4">Nonsymmetric Rank Minimization</a></li><li><a href="#5">Sparsity Regulated Rank Minimzation</a></li></ul></div><h2 id="1">Sparse Optimization MM Algorithm</h2><p>I coded a funtion sparseOptimizationMM.m that does an MM algorithm for for any regularizer, so far i have SCAD, LogDet, and the LPCC regularizers programmed for it.  The code can acomidate any regularizer with just a couple extra lines of code, and takes the name of the regularizer as input.</p><p>Its good code.</p><pre class="codeinput">m=200;
n=10000;
s=30;

A=(rand(m,n)-0.5)*10;
xSoln=zeros(n,1);
xSoln(datasample(1:n, s))=0.5+rand(s,1)*5;
b=A*xSoln;

[xSCAD,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"SCAD"</span>, 0.5,2});
[xLogDet,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"LogDet"</span>,0.5 });
[x,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"MR"</span>, 0.1});
xL1 = linprog(ones(n,1),[],[],A,b, zeros(n,1), []);

fprintf(<span class="string">"SCAD sparsity:   %i\n"</span>, sum(xSCAD&gt;0));
fprintf(<span class="string">"LogDet sparsity: %i\n"</span>, sum(xSCAD&gt;0));
fprintf(<span class="string">"LPCC sparsity:   %i\n"</span>, sum(x&gt;0));
fprintf(<span class="string">"L1 sparsity:     %i\n"</span>, sum(xL1&gt;0));
</pre><pre class="codeoutput">
Optimal solution found.


Optimal solution found.


Optimal solution found.


Optimal solution found.


Optimal solution found.


Optimal solution found.


Optimal solution found.

SCAD sparsity:   31
LogDet sparsity: 31
LPCC sparsity:   30
L1 sparsity:     99
</pre><h2 id="2">A comparison of all these methods</h2><pre class="codeinput">n=10000;
s=30;
spasity=[];
error=[];
mList=100:10:250;
<span class="keyword">if</span> exist(<span class="string">"sparse_mm_comparison.mat"</span>, <span class="string">'file'</span>)~=2
<span class="keyword">for</span> i=1:length(mList)
    m=mList(i);
    A=(rand(m,n)-0.5)*10;
    xSoln=zeros(n,1);
    xSoln(datasample(1:n, s))=rand(s,1)*5;
    b=A*xSoln;

    [xSCAD,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"SCAD"</span>, 0.075,2.5});
    [xLogDet,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"LogDet"</span>,0.1 });
    [xLPCC,obj]=sparseOptimizationMM(zeros(n,1), A,b, {<span class="string">"MR"</span>, 0.1});
    xL1 = linprog(ones(n,1),[],[],A,b, zeros(n,1), []);


    sparity(1,i)= sum(xSCAD~=0);
    sparity(2,i)= sum(xLogDet~=0);
    sparity(3,i)= sum(xLPCC~=0);
    sparity(4,i)= sum(xL1~=0);

    error(1,i)=norm(xSCAD-xSoln)/norm(xSoln);
    error(2,i)=norm(xLogDet-xSoln)/norm(xSoln);
    error(3,i)=norm(xLPCC-xSoln)/norm(xSoln);
    error(4,i)=norm(xL1-xSoln)/norm(xSoln);

<span class="keyword">end</span>
save(<span class="string">"sparse_mm_comparison.mat"</span>)
<span class="keyword">else</span>
    load(<span class="string">"sparse_mm_comparison.mat"</span>)
<span class="keyword">end</span>

[rankTable, errorTable]=displayResults(mList, sparity', error', [], {<span class="string">'Number_of_Constraints'</span>, <span class="string">'SCAD'</span>, <span class="string">'LogDet'</span>, <span class="string">'LPCC'</span>, <span class="string">'l1_Norm'</span>});
</pre><pre class="codeoutput">Rank:
    Number_of_Constraints    SCAD    LogDet    LPCC    l1_Norm
    _____________________    ____    ______    ____    _______

    100                      100     100       100     100    
    110                      110     110       110     110    
    120                      120     120       120     120    
    130                      130     130       130     130    
    140                      140     140       140     140    
    150                      150     150       150     150    
    160                      160      30       160     160    
    170                      170      29        29     170    
    180                       36      30        30     180    
    190                      190      30       190     190    
    200                       30      30        30     200    
    210                       30      30        30     179    
    220                       30      30        30     187    
    230                       30      30        30     204    
    240                       32      34        30     213    
    250                       31      30        30     203    

Error:
    Number_of_Constraints       SCAD         LogDet         LPCC        l1_Norm  
    _____________________    __________    __________    __________    __________

    100                         0.97911       0.98312       0.97314       0.96949
    110                         0.88399       0.84348       0.86227       0.83899
    120                         0.82743       0.81978       0.81822        0.8139
    130                         0.72872       0.73528       0.72703       0.72367
    140                         0.80924       0.80295       0.80191       0.77673
    150                         0.60017       0.54888       0.57585       0.56406
    160                         0.44907    5.8221e-15       0.38312       0.43277
    170                         0.30794    5.5219e-15    8.5049e-15        0.3747
    180                       4.537e-14    2.0288e-14     1.678e-14      0.061486
    190                          0.5334    2.2112e-14       0.55143       0.54732
    200                      4.9853e-15    5.6221e-15    6.1232e-15      0.054626
    210                      3.4887e-15    3.2838e-15    4.5218e-15    3.7997e-13
    220                      6.3622e-15    8.9225e-15    6.9241e-15    1.8984e-13
    230                      7.0216e-15    1.6784e-14    7.9392e-15    4.1322e-13
    240                      4.3034e-14    4.0884e-14    1.0467e-14    4.3035e-13
    250                      6.1237e-14    4.3799e-15    2.3309e-15    2.9297e-13


runTimeTable =

     []

</pre><img vspace="5" hspace="5" src="December11_01.png" style="width:1009px;height:489px;" alt=""> <h2 id="3">Extending to PSD Rank Minimization</h2><p>I now use pretty much the same algorithm for rank mimization.  In general, for a regularizer <img src="December11_eq17100803527408722578.png" alt="$f(x_i)$" style="width:31px;height:15px;">, the weight matrix <img src="December11_eq17294294712304175540.png" alt="$W^n$" style="width:21px;height:11px;"> is defined as <img src="December11_eq05553194761651142176.png" alt="$$W^n={P^n}^T diag(f'(\sigma_1), f'(\sigma_2), ..., f'(\sigma_n)) P^n$" style="width:272px;height:18px;">$ Where <img src="December11_eq13495154567458887152.png" alt="$$X^n={P^n}^T diag(\sigma_1, \sigma_2, ..., \sigma_n) P^n$" style="width:199px;height:18px;">$</p><pre class="codeinput">n=50;
r=3;
p=0.2;
rankTol=0.00001;
[D, A, b]=generateMatrixCompletionProblemPSD(n,r,p,0);
[XMR,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {<span class="string">"MR"</span>,1});
[XlogDet,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {<span class="string">"LogDet"</span>,1});
[XSCAD,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {<span class="string">"SCAD"</span>,4,3});
[ Xnuc ] = nuclearNormPSD(zeros(n,n),[],[],0,A,b, []);

fprintf(<span class="string">"SCAD rank:   %i\n"</span>, sum(svd(XSCAD)&gt;rankTol));
fprintf(<span class="string">"MR rank:     %i\n"</span>, sum(svd(XMR)&gt;rankTol));
fprintf(<span class="string">"LogDet rank: %i\n"</span>, sum(svd(XlogDet)&gt;rankTol));
fprintf(<span class="string">"NNM rank:    %i\n"</span>, sum(svd(Xnuc)&gt;rankTol));


fprintf(<span class="string">"SCAD error:   %f\n"</span>, norm(XSCAD-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"MR error:     %f\n"</span>, norm(XMR-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"LogDet error: %f\n"</span>, norm(XlogDet-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"NNM error:    %f\n"</span>, norm(Xnuc-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));


figure()
hold <span class="string">on</span>
plot(svd(Xnuc), <span class="string">'-'</span>)
plot(svd(XlogDet),<span class="string">'--'</span>)
plot(svd(XMR),<span class="string">':'</span>)
plot(svd(XSCAD), <span class="string">'-.'</span>)
</pre><pre class="codeoutput">SCAD rank:   3
MR rank:     3
LogDet rank: 3
NNM rank:    13
SCAD error:   0.000000
MR error:     0.000000
LogDet error: 0.000000
NNM error:    0.296228
</pre><img vspace="5" hspace="5" src="December11_02.png" style="width:560px;height:420px;" alt=""> <h2 id="4">Nonsymmetric Rank Minimization</h2><p>Again, not much really changes here.  Replace <img src="December11_eq12362013959998143435.png" alt="$X$" style="width:13px;height:11px;"> with <img src="December11_eq07002278246867534011.png" alt="$X^TX$" style="width:34px;height:13px;"> everywhere besides the constraints.</p><pre class="codeinput">m=100;
n=50;
r=3;
p=0.2;
rankTol=0.1;
X0=zeros(m,n);
[D, A, b]=generateMatrixCompletionProblem(n,m,r,p,0);

[ Xnuc ] = nuclearNorm(X0,[],[],0,A,b, []);
[XMR,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {<span class="string">"MR"</span>,3});
[XlogDet,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {<span class="string">"LogDet"</span>,3});
[XSCAD,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {<span class="string">"SCAD"</span>,2,4});


fprintf(<span class="string">"SCAD rank:   %i\n"</span>, sum(svd(XSCAD)&gt;rankTol));
fprintf(<span class="string">"MR rank:     %i\n"</span>, sum(svd(XMR)&gt;rankTol));
fprintf(<span class="string">"LogDet rank: %i\n"</span>, sum(svd(XlogDet)&gt;rankTol));
fprintf(<span class="string">"NNM rank:    %i\n"</span>, sum(svd(Xnuc)&gt;rankTol));

fprintf(<span class="string">"SCAD error:   %f\n"</span>, norm(XSCAD-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"MR error:     %f\n"</span>, norm(XMR-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"LogDet error: %f\n"</span>, norm(XlogDet-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));
fprintf(<span class="string">"NNM error:    %f\n"</span>, norm(Xnuc-D,<span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>));


figure()
hold <span class="string">on</span>
plot(svd(Xnuc), <span class="string">'-'</span>)
plot(svd(XlogDet),<span class="string">'--'</span>)
plot(svd(XMR),<span class="string">':'</span>)
plot(svd(XSCAD), <span class="string">'-.'</span>)
</pre><pre class="codeoutput">SCAD rank:   6
MR rank:     7
LogDet rank: 14
NNM rank:    16
SCAD error:   0.305997
MR error:     0.025429
LogDet error: 0.039695
NNM error:    0.237083
</pre><img vspace="5" hspace="5" src="December11_03.png" style="width:560px;height:420px;" alt=""> <h2 id="5">Sparsity Regulated Rank Minimzation</h2><p>now lets do an MM algorithm that combines both of these.  For a surrogate function, we just need to add the surrogate functions for rank and l0. we can mix and match the different regularizers if we want, i suppose.</p><pre class="codeinput">[D,S, A, b]=generateRobustMatrixCompletionProblem(100,50,5,500,0.7, 0);
[ Xc, Sc ] = sparsityRegulatedRankMinimizationConvex( zeros(100,50), [],[],0, A,b, {0.1});
[ Xmm, Smm ] = sparsityRegulatedRankMinimizationMM( Xc, [],[],0, A,b, {0.1,{<span class="string">'lpcc'</span>, 1},{<span class="string">'MR'</span>, 0.1}});
sum(sum(abs(full(Sc))&gt;0.00001))
sum(sum(abs(full(Smm))&gt;0.00001))
norm(Xc-D, <span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>)
norm(Xmm-D, <span class="string">'fro'</span>)/norm(D,<span class="string">'fro'</span>)

heatmap(abs(Sc))
figure
heatmap(abs(Smm))
</pre><pre class="codeoutput">
ans =

   639


ans =

   304


ans =

    0.0523


ans =

    0.0065

</pre><pre class="codeoutput error">Error using heatmap (line 82)
Adding HeatmapChart to axes is not supported. Turn hold off.

Error in December11 (line 156)
heatmap(abs(Sc))
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Sparse Optimization MM Algorithm
% I coded a funtion sparseOptimizationMM.m that does an MM algorithm for
% for any regularizer, so far i have SCAD, LogDet, and the LPCC
% regularizers programmed for it.  The code can acomidate any regularizer
% with just a couple extra lines of code, and takes the name of the
% regularizer as input.
%
% Its good code.

m=200;
n=10000;
s=30;

A=(rand(m,n)-0.5)*10;
xSoln=zeros(n,1);
xSoln(datasample(1:n, s))=0.5+rand(s,1)*5;
b=A*xSoln;

[xSCAD,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"SCAD", 0.5,2});
[xLogDet,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"LogDet",0.5 });
[x,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"MR", 0.1});
xL1 = linprog(ones(n,1),[],[],A,b, zeros(n,1), []);

fprintf("SCAD sparsity:   %i\n", sum(xSCAD>0));
fprintf("LogDet sparsity: %i\n", sum(xSCAD>0));
fprintf("LPCC sparsity:   %i\n", sum(x>0));
fprintf("L1 sparsity:     %i\n", sum(xL1>0));



%% A comparison of all these methods

n=10000;
s=30;
spasity=[];
error=[];
mList=100:10:250;
if exist("sparse_mm_comparison.mat", 'file')~=2
for i=1:length(mList)
    m=mList(i);
    A=(rand(m,n)-0.5)*10;
    xSoln=zeros(n,1);
    xSoln(datasample(1:n, s))=rand(s,1)*5;
    b=A*xSoln;
    
    [xSCAD,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"SCAD", 0.075,2.5});
    [xLogDet,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"LogDet",0.1 });
    [xLPCC,obj]=sparseOptimizationMM(zeros(n,1), A,b, {"MR", 0.1});
    xL1 = linprog(ones(n,1),[],[],A,b, zeros(n,1), []);
    
    
    sparity(1,i)= sum(xSCAD~=0);
    sparity(2,i)= sum(xLogDet~=0);
    sparity(3,i)= sum(xLPCC~=0);
    sparity(4,i)= sum(xL1~=0);
    
    error(1,i)=norm(xSCAD-xSoln)/norm(xSoln);
    error(2,i)=norm(xLogDet-xSoln)/norm(xSoln);
    error(3,i)=norm(xLPCC-xSoln)/norm(xSoln);
    error(4,i)=norm(xL1-xSoln)/norm(xSoln);
    
end
save("sparse_mm_comparison.mat")
else
    load("sparse_mm_comparison.mat")
end

[rankTable, errorTable]=displayResults(mList, sparity', error', [], {'Number_of_Constraints', 'SCAD', 'LogDet', 'LPCC', 'l1_Norm'});

%% Extending to PSD Rank Minimization
% I now use pretty much the same algorithm for rank mimization.  In
% general, for a regularizer $f(x_i)$, the weight matrix $W^n$ is defined
% as
% $$W^n={P^n}^T diag(f'(\sigma_1), f'(\sigma_2), ..., f'(\sigma_n)) P^n$$
% Where
% $$X^n={P^n}^T diag(\sigma_1, \sigma_2, ..., \sigma_n) P^n$$

n=50;
r=3;
p=0.2;
rankTol=0.00001;
[D, A, b]=generateMatrixCompletionProblemPSD(n,r,p,0);
[XMR,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {"MR",1});
[XlogDet,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {"LogDet",1});
[XSCAD,obj]=rankMinimizationPSDMM(zeros(n,n), [], [], 0, A, b, {"SCAD",4,3});
[ Xnuc ] = nuclearNormPSD(zeros(n,n),[],[],0,A,b, []);

fprintf("SCAD rank:   %i\n", sum(svd(XSCAD)>rankTol));
fprintf("MR rank:     %i\n", sum(svd(XMR)>rankTol));
fprintf("LogDet rank: %i\n", sum(svd(XlogDet)>rankTol));
fprintf("NNM rank:    %i\n", sum(svd(Xnuc)>rankTol));


fprintf("SCAD error:   %f\n", norm(XSCAD-D,'fro')/norm(D,'fro'));
fprintf("MR error:     %f\n", norm(XMR-D,'fro')/norm(D,'fro'));
fprintf("LogDet error: %f\n", norm(XlogDet-D,'fro')/norm(D,'fro'));
fprintf("NNM error:    %f\n", norm(Xnuc-D,'fro')/norm(D,'fro'));


figure()
hold on
plot(svd(Xnuc), '-')
plot(svd(XlogDet),'REPLACE_WITH_DASH_DASH')
plot(svd(XMR),':')
plot(svd(XSCAD), '-.')
%% Nonsymmetric Rank Minimization
% Again, not much really changes here.  Replace $X$ with $X^TX$ everywhere
% besides the constraints.

m=100;
n=50;
r=3;
p=0.2;
rankTol=0.1;
X0=zeros(m,n);
[D, A, b]=generateMatrixCompletionProblem(n,m,r,p,0);

[ Xnuc ] = nuclearNorm(X0,[],[],0,A,b, []);
[XMR,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {"MR",3});
[XlogDet,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {"LogDet",3});
[XSCAD,obj]=rankMinimizationMM(Xnuc, [], [], 0, A, b, {"SCAD",2,4});


fprintf("SCAD rank:   %i\n", sum(svd(XSCAD)>rankTol));
fprintf("MR rank:     %i\n", sum(svd(XMR)>rankTol));
fprintf("LogDet rank: %i\n", sum(svd(XlogDet)>rankTol));
fprintf("NNM rank:    %i\n", sum(svd(Xnuc)>rankTol));

fprintf("SCAD error:   %f\n", norm(XSCAD-D,'fro')/norm(D,'fro'));
fprintf("MR error:     %f\n", norm(XMR-D,'fro')/norm(D,'fro'));
fprintf("LogDet error: %f\n", norm(XlogDet-D,'fro')/norm(D,'fro'));
fprintf("NNM error:    %f\n", norm(Xnuc-D,'fro')/norm(D,'fro'));


figure()
hold on
plot(svd(Xnuc), '-')
plot(svd(XlogDet),'REPLACE_WITH_DASH_DASH')
plot(svd(XMR),':')
plot(svd(XSCAD), '-.')

%% Sparsity Regulated Rank Minimzation
%
% now lets do an MM algorithm that combines both of these.  For a surrogate
% function, we just need to add the surrogate functions for rank and l0.
% we can mix and match the different regularizers if we want, i suppose.

[D,S, A, b]=generateRobustMatrixCompletionProblem(100,50,5,500,0.7, 0);
[ Xc, Sc ] = sparsityRegulatedRankMinimizationConvex( zeros(100,50), [],[],0, A,b, {0.1});
[ Xmm, Smm ] = sparsityRegulatedRankMinimizationMM( Xc, [],[],0, A,b, {0.1,{'lpcc', 1},{'MR', 0.1}});
sum(sum(abs(full(Sc))>0.00001))
sum(sum(abs(full(Smm))>0.00001))
norm(Xc-D, 'fro')/norm(D,'fro')
norm(Xmm-D, 'fro')/norm(D,'fro')

heatmap(abs(Sc))
figure
heatmap(abs(Smm))
##### SOURCE END #####
--></body></html>